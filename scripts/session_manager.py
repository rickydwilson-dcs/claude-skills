#!/usr/bin/env python3
"""
Session Manager - Core CLI tool for session lifecycle management

This script manages the session-based output organization system for claude-skills.
It provides commands for creating, listing, searching, and managing work sessions.

Usage:
    session_manager.py create --ticket PROJ-123 --project "Invoice Automation"
    session_manager.py list [--user USER] [--status active]
    session_manager.py search --ticket PROJ-123
    session_manager.py close [SESSION_ID]
    session_manager.py report [SESSION_ID]

Requirements:
    - Python 3.8+
    - Standard library only (no external dependencies)
    - Git repository with user.name and user.email configured
"""

import argparse
import os
import re
import secrets
import subprocess
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple

try:
    import yaml
except ImportError:
    # Basic YAML implementation for writing (read-only for our use case)
    class SimpleYAML:
        @staticmethod
        def dump(data, stream):
            """Simple YAML serializer for our use case."""
            import json
            # Convert to YAML-like format (basic implementation)
            stream.write("# Generated by session_manager.py\n")
            SimpleYAML._dump_dict(data, stream, indent=0)

        @staticmethod
        def _dump_dict(data, stream, indent):
            """Recursively dump dictionary."""
            prefix = "  " * indent
            for key, value in data.items():
                if value is None:
                    stream.write(f"{prefix}{key}: null\n")
                elif isinstance(value, bool):
                    stream.write(f"{prefix}{key}: {'true' if value else 'false'}\n")
                elif isinstance(value, (int, float)):
                    stream.write(f"{prefix}{key}: {value}\n")
                elif isinstance(value, str):
                    if '\n' in value:
                        stream.write(f"{prefix}{key}: |\n")
                        for line in value.split('\n'):
                            stream.write(f"{prefix}  {line}\n")
                    elif value == "":
                        stream.write(f'{prefix}{key}: ""\n')
                    else:
                        stream.write(f'{prefix}{key}: "{value}"\n')
                elif isinstance(value, list):
                    if not value:
                        stream.write(f"{prefix}{key}: []\n")
                    else:
                        stream.write(f"{prefix}{key}:\n")
                        for item in value:
                            if isinstance(item, dict):
                                stream.write(f"{prefix}- ")
                                SimpleYAML._dump_dict(item, stream, indent + 1)
                            else:
                                stream.write(f'{prefix}- "{item}"\n')
                elif isinstance(value, dict):
                    stream.write(f"{prefix}{key}:\n")
                    SimpleYAML._dump_dict(value, stream, indent + 1)

        @staticmethod
        def safe_load(stream):
            """Basic YAML loader - for reading metadata."""
            import re
            data = {}
            current_key = None
            current_list = None
            indent_stack = [data]

            for line in stream:
                line = line.rstrip('\n')
                if not line.strip() or line.strip().startswith('#'):
                    continue

                # Simple key: value parsing
                if ':' in line and not line.strip().startswith('-'):
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()

                    if value in ('null', ''):
                        data[key] = None
                    elif value == 'true':
                        data[key] = True
                    elif value == 'false':
                        data[key] = False
                    elif value == '[]':
                        data[key] = []
                    elif value == '{}':
                        data[key] = {}
                    elif value.startswith('"') and value.endswith('"'):
                        data[key] = value[1:-1]
                    else:
                        data[key] = value

            return data

    yaml = SimpleYAML()


# ============================================================================
# CONFIGURATION
# ============================================================================

REPO_ROOT = Path(__file__).parent.parent.absolute()
OUTPUT_DIR = REPO_ROOT / "output"
SESSIONS_DIR = OUTPUT_DIR / "sessions"
SHARED_DIR = OUTPUT_DIR / "shared"
CURRENT_SESSION_FILE = OUTPUT_DIR / ".current-session"
METADATA_FILENAME = ".session-metadata.yaml"
TEMPLATE_PATH = REPO_ROOT / "templates" / "session-metadata-template.yaml"

RETENTION_POLICIES = {
    "project": timedelta(days=180),   # 6 months
    "sprint": timedelta(days=21),     # 3 weeks
    "temporary": timedelta(days=30)   # 30 days
}

VALID_TEAMS = ["marketing", "product", "engineering", "delivery"]
VALID_STATUSES = ["active", "closed", "archived"]
VALID_TYPES = ["architecture", "analysis", "reviews", "reports", "artifacts"]


# ============================================================================
# GIT UTILITIES
# ============================================================================

def run_git_command(args: List[str]) -> Optional[str]:
    """Run a git command and return output."""
    try:
        result = subprocess.run(
            ["git"] + args,
            cwd=REPO_ROOT,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_git_user() -> Tuple[Optional[str], Optional[str]]:
    """Get git user name and email."""
    name = run_git_command(["config", "user.name"])
    email = run_git_command(["config", "user.email"])
    return name, email


def get_current_branch() -> Optional[str]:
    """Get current git branch name."""
    return run_git_command(["rev-parse", "--abbrev-ref", "HEAD"])


def sanitize_username(git_user_name: str) -> str:
    """Convert git user.name to directory-safe format."""
    if not git_user_name:
        return "unknown-user"

    # Lowercase, replace spaces/underscores with hyphens, remove special chars
    sanitized = git_user_name.lower()
    sanitized = re.sub(r'[\s_]+', '-', sanitized)
    sanitized = re.sub(r'[^a-z0-9-]', '', sanitized)
    sanitized = re.sub(r'-+', '-', sanitized)  # Collapse multiple hyphens
    sanitized = sanitized.strip('-')
    return sanitized or 'unknown-user'


def sanitize_branch_name(branch_name: str) -> str:
    """Sanitize branch name for session ID."""
    if not branch_name:
        return "no-branch"

    branch_slug = branch_name.lower()
    branch_slug = re.sub(r'[^a-z0-9-]', '-', branch_slug)
    branch_slug = re.sub(r'-+', '-', branch_slug)
    branch_slug = branch_slug.strip('-')
    branch_slug = branch_slug[:30]  # Limit length
    return branch_slug or "no-branch"


# ============================================================================
# SESSION MANAGEMENT
# ============================================================================

def generate_session_id(branch_name: str) -> str:
    """Generate unique session identifier."""
    date_str = datetime.now().strftime("%Y-%m-%d")
    branch_slug = sanitize_branch_name(branch_name)
    short_hash = secrets.token_hex(3)  # 6 characters
    return f"{date_str}_{branch_slug}_{short_hash}"


def create_session_metadata(
    session_id: str,
    user: str,
    email: str,
    team: str,
    branch: str,
    ticket: Optional[str],
    project: str,
    retention_policy: str,
    sprint: Optional[str] = None,
    epic: Optional[str] = None,
    release: Optional[str] = None
) -> Dict:
    """Create session metadata dictionary."""
    now = datetime.utcnow()
    created_at = now.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Calculate expiration based on retention policy
    delta = RETENTION_POLICIES.get(retention_policy, timedelta(days=30))
    expires_at = (now + delta).strftime("%Y-%m-%d")

    metadata = {
        "session_id": session_id,
        "created_at": created_at,
        "created_by": {
            "user": user,
            "email": email,
            "team": team
        },
        "context": {
            "branch": branch,
            "ticket": ticket or "",
            "project": project,
            "sprint": sprint or "",
            "epic": epic or "",
            "release": release or ""
        },
        "status": {
            "current": "active",
            "closed_at": None,
            "archived_at": None
        },
        "outputs": [],
        "stakeholders": [],
        "retention": {
            "policy": retention_policy,
            "expires_at": expires_at,
            "reason": f"{retention_policy.capitalize()} retention policy"
        },
        "links": {
            "jira": "",
            "confluence": "",
            "onedrive": "",
            "github_pr": ""
        },
        "tags": [],
        "notes": ""
    }

    return metadata


def create_session(
    ticket: Optional[str],
    project: str,
    team: Optional[str] = None,
    retention: str = "project",
    sprint: Optional[str] = None,
    epic: Optional[str] = None,
    release: Optional[str] = None
) -> Tuple[bool, str, Optional[Path]]:
    """
    Create a new session.

    Returns:
        Tuple of (success, message, session_path)
    """
    # Get git user info
    git_user, git_email = get_git_user()
    if not git_user or not git_email:
        return False, "Git user not configured. Run: git config user.name 'Your Name' && git config user.email 'you@example.com'", None

    # Get current branch
    branch = get_current_branch()
    if not branch:
        return False, "Could not determine current git branch", None

    # Sanitize user name
    user = sanitize_username(git_user)

    # Prompt for team if not provided
    if not team:
        print("\nAvailable teams: marketing, product, engineering, delivery")
        team = input("Enter team: ").strip().lower()
        if team not in VALID_TEAMS:
            return False, f"Invalid team. Must be one of: {', '.join(VALID_TEAMS)}", None

    # Generate session ID
    session_id = generate_session_id(branch)

    # Create session directory structure
    user_dir = SESSIONS_DIR / user
    session_dir = user_dir / session_id

    # Check for collision (extremely unlikely)
    if session_dir.exists():
        # Regenerate with new hash
        session_id = generate_session_id(branch)
        session_dir = user_dir / session_id
        if session_dir.exists():
            return False, "Session collision detected (extremely rare). Please try again.", None

    # Create session directory (flat structure)
    try:
        session_dir.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        return False, f"Failed to create session directory: {e}", None

    # Create metadata
    metadata = create_session_metadata(
        session_id=session_id,
        user=user,
        email=git_email,
        team=team,
        branch=branch,
        ticket=ticket,
        project=project,
        retention_policy=retention,
        sprint=sprint,
        epic=epic,
        release=release
    )

    # Write metadata file
    metadata_path = session_dir / METADATA_FILENAME
    try:
        with open(metadata_path, 'w') as f:
            yaml.dump(metadata, f)
    except Exception as e:
        return False, f"Failed to write metadata: {e}", None

    # Set as current session
    try:
        with open(CURRENT_SESSION_FILE, 'w') as f:
            f.write(f"{user}/{session_id}")
    except Exception as e:
        return False, f"Failed to set current session: {e}", None

    message = f"""
âœ… Session created successfully!

ðŸ“ Session Directory: {session_dir}
ðŸ“ Metadata: {metadata_path}
ðŸ”— Session ID: {session_id}
ðŸ‘¤ User: {user}
ðŸ¢ Team: {team}
ðŸŒ¿ Branch: {branch}
ðŸŽ« Ticket: {ticket or 'N/A'}
ðŸ“¦ Project: {project}

ðŸ’¡ Use this session:
   export CLAUDE_SESSION_DIR="{session_dir}"

ðŸ“Š View session:
   python3 scripts/session_manager.py report
"""

    return True, message, session_dir


def list_sessions(
    user: Optional[str] = None,
    status: Optional[str] = None,
    team: Optional[str] = None
) -> List[Dict]:
    """List all sessions matching criteria."""
    sessions = []

    if not SESSIONS_DIR.exists():
        return sessions

    # Iterate through user directories
    for user_dir in SESSIONS_DIR.iterdir():
        if not user_dir.is_dir():
            continue

        # Filter by user if specified
        if user and user_dir.name != user:
            continue

        # Iterate through session directories
        for session_dir in user_dir.iterdir():
            if not session_dir.is_dir():
                continue

            metadata_path = session_dir / METADATA_FILENAME
            if not metadata_path.exists():
                continue

            try:
                with open(metadata_path, 'r') as f:
                    metadata = yaml.safe_load(f)

                # Filter by status if specified
                if status and metadata.get("status", {}).get("current") != status:
                    continue

                # Filter by team if specified
                if team and metadata.get("created_by", {}).get("team") != team:
                    continue

                sessions.append({
                    "user": user_dir.name,
                    "session_id": session_dir.name,
                    "path": session_dir,
                    "metadata": metadata
                })
            except Exception as e:
                print(f"Warning: Could not read metadata for {session_dir}: {e}", file=sys.stderr)
                continue

    return sessions


def get_current_session() -> Optional[Tuple[str, Path]]:
    """Get the current active session."""
    if not CURRENT_SESSION_FILE.exists():
        return None

    try:
        with open(CURRENT_SESSION_FILE, 'r') as f:
            session_path = f.read().strip()

        if '/' not in session_path:
            return None

        full_path = SESSIONS_DIR / session_path
        if not full_path.exists():
            return None

        return session_path, full_path
    except Exception:
        return None


def close_session(session_id: Optional[str] = None) -> Tuple[bool, str]:
    """Close a session."""
    if not session_id:
        # Close current session
        current = get_current_session()
        if not current:
            return False, "No current session active"
        session_path, session_dir = current
    else:
        # Find session by ID
        sessions = list_sessions()
        matching = [s for s in sessions if s["session_id"] == session_id]
        if not matching:
            return False, f"Session not found: {session_id}"
        session_dir = matching[0]["path"]

    # Update metadata
    metadata_path = session_dir / METADATA_FILENAME
    try:
        with open(metadata_path, 'r') as f:
            metadata = yaml.safe_load(f)

        metadata["status"]["current"] = "closed"
        metadata["status"]["closed_at"] = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

        with open(metadata_path, 'w') as f:
            yaml.dump(metadata, f)

        # Clear current session file
        if CURRENT_SESSION_FILE.exists():
            CURRENT_SESSION_FILE.unlink()

        return True, f"Session closed: {session_dir.name}"
    except Exception as e:
        return False, f"Failed to close session: {e}"


def search_sessions(
    ticket: Optional[str] = None,
    project: Optional[str] = None,
    agent: Optional[str] = None,
    tag: Optional[str] = None
) -> List[Dict]:
    """Search sessions by various criteria."""
    all_sessions = list_sessions()
    results = []

    for session in all_sessions:
        metadata = session["metadata"]

        # Filter by ticket
        if ticket:
            ctx_ticket = metadata.get("context", {}).get("ticket", "")
            if ticket.lower() not in ctx_ticket.lower():
                continue

        # Filter by project
        if project:
            ctx_project = metadata.get("context", {}).get("project", "")
            if project.lower() not in ctx_project.lower():
                continue

        # Filter by agent
        if agent:
            outputs = metadata.get("outputs", [])
            if not any(agent.lower() in o.get("agent", "").lower() for o in outputs):
                continue

        # Filter by tag
        if tag:
            tags = metadata.get("tags", [])
            if not any(tag.lower() in t.lower() for t in tags):
                continue

        results.append(session)

    return results


def generate_report(session_id: Optional[str] = None, format: str = "markdown") -> str:
    """Generate a report for a session."""
    if not session_id:
        # Report on current session
        current = get_current_session()
        if not current:
            return "No current session active"
        session_path, session_dir = current
    else:
        # Find session by ID
        sessions = list_sessions()
        matching = [s for s in sessions if s["session_id"] == session_id]
        if not matching:
            return f"Session not found: {session_id}"
        session_dir = matching[0]["path"]

    # Load metadata
    metadata_path = session_dir / METADATA_FILENAME
    try:
        with open(metadata_path, 'r') as f:
            metadata = yaml.safe_load(f)
    except Exception as e:
        return f"Failed to read metadata: {e}"

    if format == "json":
        import json
        return json.dumps(metadata, indent=2)

    # Markdown format
    report = f"""# Session Report

## Session Information
- **Session ID:** {metadata['session_id']}
- **Created:** {metadata['created_at']}
- **User:** {metadata['created_by']['user']}
- **Email:** {metadata['created_by']['email']}
- **Team:** {metadata['created_by']['team']}
- **Status:** {metadata['status']['current']}

## Work Context
- **Branch:** {metadata['context']['branch']}
- **Ticket:** {metadata['context']['ticket'] or 'N/A'}
- **Project:** {metadata['context']['project']}
- **Sprint:** {metadata['context'].get('sprint', 'N/A')}
- **Epic:** {metadata['context'].get('epic', 'N/A')}
- **Release:** {metadata['context'].get('release', 'N/A')}

## Outputs ({len(metadata.get('outputs', []))})
"""

    outputs = metadata.get('outputs', [])
    if outputs:
        for i, output in enumerate(outputs, 1):
            report += f"""
{i}. **{output['file']}**
   - Agent: {output['agent']}
   - Type: {output['type']}
   - Created: {output['created_at']}
   - Promoted: {'Yes' if output.get('promoted') else 'No'}
"""
            if output.get('promoted_to'):
                report += f"   - Promoted to: {output['promoted_to']}\n"
    else:
        report += "\nNo outputs yet.\n"

    report += f"""
## Retention
- **Policy:** {metadata['retention']['policy']}
- **Expires:** {metadata['retention']['expires_at']}
- **Reason:** {metadata['retention'].get('reason', 'N/A')}

## Path
`{session_dir}`
"""

    return report


# ============================================================================
# CLI INTERFACE
# ============================================================================

def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(
        description="Session Manager - Manage claude-skills work sessions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Create a new session
  %(prog)s create --ticket PROJ-123 --project "Invoice Automation" --team engineering

  # List all active sessions
  %(prog)s list --status active

  # Search for sessions by ticket
  %(prog)s search --ticket PROJ-123

  # Close current session
  %(prog)s close

  # Generate report for current session
  %(prog)s report
"""
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # Create command
    create_parser = subparsers.add_parser("create", help="Create a new session")
    create_parser.add_argument("--ticket", help="Jira ticket ID (e.g., PROJ-123)")
    create_parser.add_argument("--project", required=True, help="Project name")
    create_parser.add_argument("--team", choices=VALID_TEAMS, help="Team name")
    create_parser.add_argument("--retention", choices=RETENTION_POLICIES.keys(),
                              default="project", help="Retention policy")
    create_parser.add_argument("--sprint", help="Sprint identifier")
    create_parser.add_argument("--epic", help="Epic ticket ID")
    create_parser.add_argument("--release", help="Release version")

    # List command
    list_parser = subparsers.add_parser("list", help="List sessions")
    list_parser.add_argument("--user", help="Filter by user")
    list_parser.add_argument("--status", choices=VALID_STATUSES, help="Filter by status")
    list_parser.add_argument("--team", choices=VALID_TEAMS, help="Filter by team")

    # Current command
    subparsers.add_parser("current", help="Show current session")

    # Search command
    search_parser = subparsers.add_parser("search", help="Search sessions")
    search_parser.add_argument("--ticket", help="Search by ticket")
    search_parser.add_argument("--project", help="Search by project")
    search_parser.add_argument("--agent", help="Search by agent")
    search_parser.add_argument("--tag", help="Search by tag")

    # Close command
    close_parser = subparsers.add_parser("close", help="Close a session")
    close_parser.add_argument("session_id", nargs="?", help="Session ID to close (or current if omitted)")

    # Report command
    report_parser = subparsers.add_parser("report", help="Generate session report")
    report_parser.add_argument("session_id", nargs="?", help="Session ID (or current if omitted)")
    report_parser.add_argument("--format", choices=["markdown", "json"], default="markdown",
                              help="Output format")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Execute command
    if args.command == "create":
        success, message, session_path = create_session(
            ticket=args.ticket,
            project=args.project,
            team=args.team,
            retention=args.retention,
            sprint=args.sprint,
            epic=args.epic,
            release=args.release
        )
        print(message)
        return 0 if success else 1

    elif args.command == "list":
        sessions = list_sessions(
            user=args.user,
            status=args.status,
            team=args.team
        )
        if not sessions:
            print("No sessions found.")
            return 0

        print(f"\nFound {len(sessions)} session(s):\n")
        for session in sessions:
            metadata = session["metadata"]
            status = metadata["status"]["current"]
            team = metadata["created_by"]["team"]
            project = metadata["context"]["project"]
            print(f"  {session['user']}/{session['session_id']}")
            print(f"    Status: {status} | Team: {team} | Project: {project}")
            print()
        return 0

    elif args.command == "current":
        current = get_current_session()
        if not current:
            print("No current session active.")
            print("\nCreate a session with: python3 scripts/session_manager.py create --project 'Your Project'")
            return 1

        session_path, session_dir = current
        print(f"\nCurrent session: {session_path}")
        print(f"Path: {session_dir}")
        print(f"\nUse in scripts:")
        print(f'  export CLAUDE_SESSION_DIR="{session_dir}"')
        return 0

    elif args.command == "search":
        results = search_sessions(
            ticket=args.ticket,
            project=args.project,
            agent=args.agent,
            tag=args.tag
        )
        if not results:
            print("No sessions found matching criteria.")
            return 0

        print(f"\nFound {len(results)} session(s):\n")
        for session in results:
            metadata = session["metadata"]
            print(f"  {session['user']}/{session['session_id']}")
            print(f"    Project: {metadata['context']['project']}")
            print(f"    Ticket: {metadata['context'].get('ticket', 'N/A')}")
            print(f"    Outputs: {len(metadata.get('outputs', []))}")
            print()
        return 0

    elif args.command == "close":
        success, message = close_session(args.session_id)
        print(message)
        return 0 if success else 1

    elif args.command == "report":
        report = generate_report(args.session_id, args.format)
        print(report)
        return 0

    return 1


if __name__ == "__main__":
    sys.exit(main())
