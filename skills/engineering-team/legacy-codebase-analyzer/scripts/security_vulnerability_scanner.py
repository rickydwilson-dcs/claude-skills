#!/usr/bin/env python3
"""
Security Vulnerability Scanner - Static Security Analysis Tool

Detects security vulnerabilities, hardcoded secrets, and compliance gaps
in legacy codebases. Scans for OWASP Top 10 issues, authentication problems,
cryptographic weaknesses, and sensitive data exposure.

Part of the legacy-codebase-analyzer skill package.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from io import StringIO
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
import argparse
import csv
import json
import logging
import os
import re
import sys


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class Severity(Enum):
    """Security issue severity levels"""
    CRITICAL = 4  # Immediate security risk - data breach, RCE
    HIGH = 3      # Significant security risk - auth bypass, injection
    MEDIUM = 2    # Moderate security risk - weak crypto, info disclosure
    LOW = 1       # Minor security risk - best practice violation


@dataclass
class Pattern:
    """Security vulnerability detection pattern"""
    id: str
    name: str
    regex: str
    severity: Severity
    category: str
    message: str
    recommendation: str
    cwe_id: Optional[str] = None  # Common Weakness Enumeration ID
    owasp: Optional[str] = None   # OWASP Top 10 mapping


@dataclass
class SecretFinding:
    """A detected hardcoded secret"""
    secret_type: str
    file_path: str
    line_number: int
    line_content: str  # Redacted version
    severity: Severity
    recommendation: str


@dataclass
class VulnerabilityFinding:
    """A detected security vulnerability"""
    pattern_id: str
    file_path: str
    line_number: int
    line_content: str
    severity: Severity
    category: str
    message: str
    recommendation: str
    cwe_id: Optional[str] = None
    owasp: Optional[str] = None


class SecurityVulnerabilityScanner:
    """Static security analysis tool for legacy codebases"""

    LANGUAGE_EXTENSIONS = {
        '.py': 'python',
        '.js': 'javascript',
        '.ts': 'typescript',
        '.tsx': 'typescript',
        '.jsx': 'javascript',
        '.java': 'java',
        '.rb': 'ruby',
        '.php': 'php',
        '.go': 'go',
        '.cs': 'csharp',
        '.c': 'c',
        '.cpp': 'cpp',
        '.h': 'c',
        '.hpp': 'cpp',
        '.sql': 'sql',
        '.sh': 'shell',
        '.bash': 'shell',
        '.env': 'config',
        '.properties': 'config',
        '.yaml': 'config',
        '.yml': 'config',
        '.json': 'config',
        '.xml': 'config',
    }

    SKIP_DIRS = {
        'node_modules', '__pycache__', '.git', '.svn', '.hg',
        'venv', 'env', '.venv', '.env', 'dist', 'build',
        '.tox', '.pytest_cache', '.mypy_cache', 'coverage',
        'vendor', 'third_party', '.idea', '.vscode', 'test',
        'tests', '__tests__', 'spec', 'specs'
    }

    # Binary and media files to skip
    SKIP_EXTENSIONS = {
        '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico',
        '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.tar',
        '.gz', '.rar', '.7z', '.mp3', '.mp4', '.avi', '.mov',
        '.exe', '.dll', '.so', '.dylib', '.pyc', '.pyo', '.class',
        '.jar', '.war', '.ear', '.woff', '.woff2', '.ttf', '.eot'
    }

    def __init__(self, target_path: str, min_severity: str = 'LOW',
                 verbose: bool = False):
        self.target_path = Path(target_path)
        self.min_severity = Severity[min_severity.upper()]
        self.verbose = verbose
        if verbose:
            logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("SecurityVulnerabilityScanner initialized")
        self.secret_patterns = self._load_secret_patterns()
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.secret_findings: List[SecretFinding] = []
        self.vulnerability_findings: List[VulnerabilityFinding] = []
        self.files_analyzed = 0
        self.results: Dict = {}

    def _load_secret_patterns(self) -> List[Pattern]:
        """Load patterns for detecting hardcoded secrets"""
        return [
            # AWS Credentials
            Pattern(
                id='SECRET001',
                name='AWS Access Key',
                regex=r'(?i)(aws_access_key_id|aws_access_key|access_key_id)\s*[=:]\s*["\']?(AKIA[0-9A-Z]{16})["\']?',
                severity=Severity.CRITICAL,
                category='Hardcoded Secrets',
                message='AWS Access Key ID detected',
                recommendation='Move AWS credentials to environment variables or AWS credentials file'
            ),
            Pattern(
                id='SECRET002',
                name='AWS Secret Access Key',
                regex=r'(?i)(aws_secret_access_key|aws_secret_key|secret_access_key)\s*[=:]\s*["\']?([A-Za-z0-9/+=]{40})["\']?',
                severity=Severity.CRITICAL,
                category='Hardcoded Secrets',
                message='AWS Secret Access Key detected',
                recommendation='Move AWS credentials to environment variables or AWS credentials file'
            ),
            # API Keys
            Pattern(
                id='SECRET003',
                name='Generic API Key',
                regex=r'(?i)(api_key|apikey|api_secret|apisecret)\s*[=:]\s*["\']([A-Za-z0-9_\-]{20,})["\']',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='API key detected in code',
                recommendation='Move API keys to environment variables or secure key management system'
            ),
            # Private Keys
            Pattern(
                id='SECRET004',
                name='Private Key',
                regex=r'-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----',
                severity=Severity.CRITICAL,
                category='Hardcoded Secrets',
                message='Private key detected in code',
                recommendation='Remove private keys from codebase and use secure key management'
            ),
            # Passwords
            Pattern(
                id='SECRET005',
                name='Hardcoded Password',
                regex=r'(?i)(password|passwd|pwd)\s*[=:]\s*["\']([^"\'\s]{8,})["\']',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='Hardcoded password detected',
                recommendation='Use environment variables or secure credential storage'
            ),
            # Database Connection Strings
            Pattern(
                id='SECRET006',
                name='Database Connection String',
                regex=r'(?i)(mongodb|mysql|postgresql|postgres)://[a-zA-Z0-9_\-]+:[^@\s]+@',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='Database connection string with credentials detected',
                recommendation='Use environment variables for database credentials'
            ),
            # JWT Secrets
            Pattern(
                id='SECRET007',
                name='JWT Secret',
                regex=r'(?i)(jwt_secret|jwtsecret|jwt_key)\s*[=:]\s*["\']([A-Za-z0-9_\-]{20,})["\']',
                severity=Severity.CRITICAL,
                category='Hardcoded Secrets',
                message='JWT secret key detected',
                recommendation='Move JWT secrets to environment variables'
            ),
            # OAuth Tokens
            Pattern(
                id='SECRET008',
                name='OAuth Token',
                regex=r'(?i)(oauth_token|oauthtoken|bearer_token)\s*[=:]\s*["\']([A-Za-z0-9_\-\.]{20,})["\']',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='OAuth token detected',
                recommendation='Use secure token storage and refresh mechanisms'
            ),
            # Slack Tokens
            Pattern(
                id='SECRET009',
                name='Slack Token',
                regex=r'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24,}',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='Slack API token detected',
                recommendation='Use environment variables for Slack tokens'
            ),
            # GitHub Tokens
            Pattern(
                id='SECRET010',
                name='GitHub Token',
                regex=r'gh[pousr]_[A-Za-z0-9_]{36,}',
                severity=Severity.HIGH,
                category='Hardcoded Secrets',
                message='GitHub access token detected',
                recommendation='Use GitHub Actions secrets or environment variables'
            ),
        ]

    def _load_vulnerability_patterns(self) -> List[Pattern]:
        """Load patterns for detecting security vulnerabilities"""
        return [
            # SQL Injection
            Pattern(
                id='VULN001',
                name='SQL Injection Risk',
                regex=r'(?i)(execute|exec|query|raw)\s*\(\s*["\']?\s*SELECT.*?\+.*?\)',
                severity=Severity.CRITICAL,
                category='OWASP A03:2021',
                message='Potential SQL injection vulnerability - string concatenation in query',
                recommendation='Use parameterized queries or prepared statements',
                cwe_id='CWE-89',
                owasp='A03:2021 - Injection'
            ),
            Pattern(
                id='VULN002',
                name='SQL Injection - Python',
                regex=r'(?i)cursor\.execute\s*\(\s*["\'].*?%s.*?["\'].*?%.*?\)',
                severity=Severity.CRITICAL,
                category='OWASP A03:2021',
                message='Potential SQL injection - using % formatting with SQL',
                recommendation='Use parameterized queries with ? or %s placeholders',
                cwe_id='CWE-89',
                owasp='A03:2021 - Injection'
            ),
            # Command Injection
            Pattern(
                id='VULN003',
                name='Command Injection',
                regex=r'(?i)(exec|eval|system|shell_exec|popen|subprocess\.call)\s*\(.*?\+.*?\)',
                severity=Severity.CRITICAL,
                category='OWASP A03:2021',
                message='Potential command injection - user input in system command',
                recommendation='Avoid dynamic command execution or use safe subprocess methods',
                cwe_id='CWE-78',
                owasp='A03:2021 - Injection'
            ),
            # XSS (Cross-Site Scripting)
            Pattern(
                id='VULN004',
                name='XSS Vulnerability',
                regex=r'(?i)(innerHTML|document\.write|\.html\()\s*.*?\+.*?',
                severity=Severity.HIGH,
                category='OWASP A03:2021',
                message='Potential XSS vulnerability - dynamic HTML content',
                recommendation='Sanitize user input and use textContent or safe templating',
                cwe_id='CWE-79',
                owasp='A03:2021 - Injection'
            ),
            Pattern(
                id='VULN005',
                name='XSS - React',
                regex=r'(?i)dangerouslySetInnerHTML',
                severity=Severity.HIGH,
                category='OWASP A03:2021',
                message='dangerouslySetInnerHTML used - potential XSS risk',
                recommendation='Sanitize HTML with DOMPurify before using dangerouslySetInnerHTML',
                cwe_id='CWE-79',
                owasp='A03:2021 - Injection'
            ),
            # Path Traversal
            Pattern(
                id='VULN006',
                name='Path Traversal',
                regex=r'(?i)(open|fopen|file_get_contents|readFile)\s*\(.*?\+.*?\)',
                severity=Severity.HIGH,
                category='OWASP A01:2021',
                message='Potential path traversal vulnerability',
                recommendation='Validate and sanitize file paths, use whitelisting',
                cwe_id='CWE-22',
                owasp='A01:2021 - Broken Access Control'
            ),
            # Insecure Deserialization
            Pattern(
                id='VULN007',
                name='Insecure Deserialization',
                regex=r'(?i)(pickle\.loads|yaml\.load|unserialize)\s*\(',
                severity=Severity.CRITICAL,
                category='OWASP A08:2021',
                message='Insecure deserialization - can lead to RCE',
                recommendation='Use safe deserialization methods (yaml.safe_load, json.loads)',
                cwe_id='CWE-502',
                owasp='A08:2021 - Software and Data Integrity Failures'
            ),
            # Weak Cryptography
            Pattern(
                id='VULN008',
                name='Weak Hash - MD5',
                regex=r'(?i)(md5|hashlib\.md5)\s*\(',
                severity=Severity.MEDIUM,
                category='Cryptography',
                message='MD5 is cryptographically broken',
                recommendation='Use SHA-256 or better (SHA-3, bcrypt for passwords)',
                cwe_id='CWE-327',
                owasp='A02:2021 - Cryptographic Failures'
            ),
            Pattern(
                id='VULN009',
                name='Weak Hash - SHA1',
                regex=r'(?i)(sha1|hashlib\.sha1)\s*\(',
                severity=Severity.MEDIUM,
                category='Cryptography',
                message='SHA1 is cryptographically weak',
                recommendation='Use SHA-256 or better',
                cwe_id='CWE-327',
                owasp='A02:2021 - Cryptographic Failures'
            ),
            Pattern(
                id='VULN010',
                name='Weak Random',
                regex=r'(?i)(random\.random|Math\.random|rand\(\))',
                severity=Severity.MEDIUM,
                category='Cryptography',
                message='Weak random number generator for security',
                recommendation='Use secrets module (Python) or crypto.randomBytes (Node.js)',
                cwe_id='CWE-338',
                owasp='A02:2021 - Cryptographic Failures'
            ),
            # Authentication Issues
            Pattern(
                id='VULN011',
                name='Weak Password Check',
                regex=r'(?i)(password|passwd)\s*==\s*["\'][^"\']{1,7}["\']',
                severity=Severity.HIGH,
                category='Authentication',
                message='Weak password check - short or hardcoded password',
                recommendation='Implement proper password hashing with bcrypt/argon2',
                cwe_id='CWE-521',
                owasp='A07:2021 - Identification and Authentication Failures'
            ),
            Pattern(
                id='VULN012',
                name='No Password Hashing',
                regex=r'(?i)password\s*==\s*.*?password\s*',
                severity=Severity.CRITICAL,
                category='Authentication',
                message='Plain text password comparison',
                recommendation='Hash passwords with bcrypt, argon2, or scrypt',
                cwe_id='CWE-916',
                owasp='A07:2021 - Identification and Authentication Failures'
            ),
            # Configuration Issues
            Pattern(
                id='VULN013',
                name='Debug Mode Enabled',
                regex=r'(?i)(debug|DEBUG)\s*[=:]\s*(true|True|TRUE|1)',
                severity=Severity.MEDIUM,
                category='Configuration',
                message='Debug mode enabled - information disclosure risk',
                recommendation='Disable debug mode in production',
                cwe_id='CWE-489',
                owasp='A05:2021 - Security Misconfiguration'
            ),
            Pattern(
                id='VULN014',
                name='CORS Misconfiguration',
                regex=r'(?i)Access-Control-Allow-Origin\s*[=:]\s*[\'"]\*[\'"]',
                severity=Severity.MEDIUM,
                category='Configuration',
                message='CORS allows all origins (*)',
                recommendation='Restrict CORS to specific trusted origins',
                cwe_id='CWE-942',
                owasp='A05:2021 - Security Misconfiguration'
            ),
            # LDAP Injection
            Pattern(
                id='VULN015',
                name='LDAP Injection',
                regex=r'(?i)ldap_search\s*\(.*?\+.*?\)',
                severity=Severity.HIGH,
                category='OWASP A03:2021',
                message='Potential LDAP injection vulnerability',
                recommendation='Sanitize user input for LDAP queries',
                cwe_id='CWE-90',
                owasp='A03:2021 - Injection'
            ),
            # XML External Entity (XXE)
            Pattern(
                id='VULN016',
                name='XXE Vulnerability',
                regex=r'(?i)(XMLParser|xml\.etree|parseXML)\s*\(.*?resolve_entities\s*=\s*True',
                severity=Severity.HIGH,
                category='OWASP A03:2021',
                message='XML parser allows external entities - XXE risk',
                recommendation='Disable external entity resolution in XML parsers',
                cwe_id='CWE-611',
                owasp='A03:2021 - Injection'
            ),
            # SSL/TLS Issues
            Pattern(
                id='VULN017',
                name='SSL Verification Disabled',
                regex=r'(?i)(verify\s*[=:]\s*False|ssl_verify\s*=\s*false|NODE_TLS_REJECT_UNAUTHORIZED\s*=\s*["\']0["\'])',
                severity=Severity.HIGH,
                category='Cryptography',
                message='SSL/TLS certificate verification disabled',
                recommendation='Enable SSL verification to prevent MITM attacks',
                cwe_id='CWE-295',
                owasp='A02:2021 - Cryptographic Failures'
            ),
            # Regex DoS
            Pattern(
                id='VULN018',
                name='ReDoS Risk',
                regex=r're\.compile\([^)]*\(.*\+.*\)\*',
                severity=Severity.MEDIUM,
                category='Availability',
                message='Potential Regular Expression Denial of Service (ReDoS)',
                recommendation='Avoid nested quantifiers in regex patterns',
                cwe_id='CWE-1333',
                owasp='A06:2021 - Vulnerable and Outdated Components'
            ),
            # Open Redirect
            Pattern(
                id='VULN019',
                name='Open Redirect',
                regex=r'(?i)(redirect|location\.href|window\.location)\s*[=\(].*?request\.',
                severity=Severity.MEDIUM,
                category='OWASP A01:2021',
                message='Potential open redirect vulnerability',
                recommendation='Validate redirect URLs against whitelist',
                cwe_id='CWE-601',
                owasp='A01:2021 - Broken Access Control'
            ),
            # File Upload
            Pattern(
                id='VULN020',
                name='Unrestricted File Upload',
                regex=r'(?i)(upload|save|write).*?filename.*?request\.',
                severity=Severity.HIGH,
                category='OWASP A04:2021',
                message='Potential unrestricted file upload',
                recommendation='Validate file types, size, and use secure file storage',
                cwe_id='CWE-434',
                owasp='A04:2021 - Insecure Design'
            ),
        ]

    def scan(self) -> Dict:
        """Run complete security scan"""
        if self.verbose:
            print(f"Scanning: {self.target_path}")

        if self.target_path.is_file():
            self._scan_file(self.target_path)
        else:
            self._scan_directory(self.target_path)

        self._generate_results()
        return self.results

    def _scan_directory(self, directory: Path):
        """Recursively scan directory for security issues"""
        for root, dirs, files in os.walk(directory):
            # Remove skip directories from traversal
            dirs[:] = [d for d in dirs if d not in self.SKIP_DIRS]

            for file_name in files:
                file_path = Path(root) / file_name

                # Skip binary files
                if file_path.suffix.lower() in self.SKIP_EXTENSIONS:
                    continue

                # Check if it's a text file
                if not self._is_text_file(file_path):
                    continue

                self._scan_file(file_path)

    def _scan_file(self, file_path: Path):
        """Scan single file for security issues"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            self.files_analyzed += 1

            for line_num, line in enumerate(lines, start=1):
                # Check for hardcoded secrets
                for pattern in self.secret_patterns:
                    if pattern.severity.value >= self.min_severity.value:
                        self._check_secret_pattern(pattern, file_path, line_num, line)

                # Check for vulnerabilities
                for pattern in self.vulnerability_patterns:
                    if pattern.severity.value >= self.min_severity.value:
                        self._check_vulnerability_pattern(pattern, file_path, line_num, line)

            if self.verbose and self.files_analyzed % 100 == 0:
                print(f"  Analyzed {self.files_analyzed} files...")

        except Exception as e:
            if self.verbose:
                print(f"  Error scanning {file_path}: {e}")

    def _is_text_file(self, file_path: Path) -> bool:
        """Check if file is text file"""
        try:
            with open(file_path, 'rb') as f:
                chunk = f.read(512)
                if b'\x00' in chunk:  # Binary file indicator
                    return False
            return True
        except Exception:
            return False

    def _check_secret_pattern(self, pattern: Pattern, file_path: Path,
                              line_num: int, line: str):
        """Check line for hardcoded secrets"""
        match = re.search(pattern.regex, line)
        if match:
            # Redact the actual secret value
            redacted_line = self._redact_secret(line, match)

            finding = SecretFinding(
                secret_type=pattern.name,
                file_path=str(file_path),
                line_number=line_num,
                line_content=redacted_line,
                severity=pattern.severity,
                recommendation=pattern.recommendation
            )
            self.secret_findings.append(finding)

    def _check_vulnerability_pattern(self, pattern: Pattern, file_path: Path,
                                     line_num: int, line: str):
        """Check line for security vulnerabilities"""
        if re.search(pattern.regex, line):
            finding = VulnerabilityFinding(
                pattern_id=pattern.id,
                file_path=str(file_path),
                line_number=line_num,
                line_content=line.strip(),
                severity=pattern.severity,
                category=pattern.category,
                message=pattern.message,
                recommendation=pattern.recommendation,
                cwe_id=pattern.cwe_id,
                owasp=pattern.owasp
            )
            self.vulnerability_findings.append(finding)

    def _redact_secret(self, line: str, match) -> str:
        """Redact sensitive data from line"""
        if len(match.groups()) >= 2:
            secret_value = match.group(2)
            # Show first 4 chars and redact rest
            if len(secret_value) > 4:
                redacted = secret_value[:4] + '*' * (len(secret_value) - 4)
            else:
                redacted = '****'
            return line.replace(secret_value, redacted)
        return line.strip()

    def _generate_results(self):
        """Generate comprehensive results"""
        # Count by severity
        critical = sum(1 for f in self.secret_findings if f.severity == Severity.CRITICAL)
        critical += sum(1 for f in self.vulnerability_findings if f.severity == Severity.CRITICAL)

        high = sum(1 for f in self.secret_findings if f.severity == Severity.HIGH)
        high += sum(1 for f in self.vulnerability_findings if f.severity == Severity.HIGH)

        medium = sum(1 for f in self.secret_findings if f.severity == Severity.MEDIUM)
        medium += sum(1 for f in self.vulnerability_findings if f.severity == Severity.MEDIUM)

        low = sum(1 for f in self.secret_findings if f.severity == Severity.LOW)
        low += sum(1 for f in self.vulnerability_findings if f.severity == Severity.LOW)

        total_findings = critical + high + medium + low

        # Calculate security score (0-100)
        security_score = self._calculate_security_score(critical, high, medium, low)

        self.results = {
            'status': 'completed',
            'timestamp': datetime.now().isoformat(),
            'target': str(self.target_path),
            'files_analyzed': self.files_analyzed,
            'summary': {
                'total_findings': total_findings,
                'critical': critical,
                'high': high,
                'medium': medium,
                'low': low,
                'security_score': security_score,
                'total_secrets': len(self.secret_findings),
                'total_vulnerabilities': len(self.vulnerability_findings)
            },
            'secrets': [self._secret_to_dict(f) for f in self.secret_findings],
            'vulnerabilities': [self._vulnerability_to_dict(f) for f in self.vulnerability_findings],
            'recommendations': self._generate_recommendations()
        }

    def _calculate_security_score(self, critical: int, high: int,
                                   medium: int, low: int) -> int:
        """
        Calculate security score (0-100)
        100 = No issues
        0 = Critical security issues
        """
        if self.files_analyzed == 0:
            return 0

        # Weighted deductions
        deduction = (
            critical * 25 +  # Critical issues are severe
            high * 10 +      # High issues significant
            medium * 3 +     # Medium moderate
            low * 1          # Low minor
        )

        # Normalize by files analyzed (issues per file)
        issues_per_file = deduction / max(self.files_analyzed, 1)

        # Score calculation (exponential decay)
        score = max(0, int(100 * (0.9 ** issues_per_file)))
        return score

    def _secret_to_dict(self, finding: SecretFinding) -> Dict:
        """Convert secret finding to dictionary"""
        return {
            'type': finding.secret_type,
            'file': finding.file_path,
            'line': finding.line_number,
            'content': finding.line_content,
            'severity': finding.severity.name,
            'recommendation': finding.recommendation
        }

    def _vulnerability_to_dict(self, finding: VulnerabilityFinding) -> Dict:
        """Convert vulnerability finding to dictionary"""
        result = {
            'id': finding.pattern_id,
            'file': finding.file_path,
            'line': finding.line_number,
            'content': finding.line_content,
            'severity': finding.severity.name,
            'category': finding.category,
            'message': finding.message,
            'recommendation': finding.recommendation
        }
        if finding.cwe_id:
            result['cwe'] = finding.cwe_id
        if finding.owasp:
            result['owasp'] = finding.owasp
        return result

    def _generate_recommendations(self) -> List[str]:
        """Generate prioritized security recommendations"""
        recommendations = []

        # Count issue types
        critical_count = sum(1 for f in self.secret_findings if f.severity == Severity.CRITICAL)
        critical_count += sum(1 for f in self.vulnerability_findings if f.severity == Severity.CRITICAL)

        if critical_count > 0:
            recommendations.append(
                f"CRITICAL: {critical_count} critical security issues found. "
                "Address immediately before deployment."
            )

        # Secrets recommendations
        if len(self.secret_findings) > 0:
            recommendations.append(
                f"Found {len(self.secret_findings)} hardcoded secrets. "
                "Move all secrets to environment variables or secure vaults."
            )

        # SQL Injection
        sql_issues = [f for f in self.vulnerability_findings
                      if f.pattern_id in ['VULN001', 'VULN002']]
        if sql_issues:
            recommendations.append(
                f"Found {len(sql_issues)} potential SQL injection vulnerabilities. "
                "Use parameterized queries or ORMs."
            )

        # Command Injection
        cmd_issues = [f for f in self.vulnerability_findings
                      if f.pattern_id == 'VULN003']
        if cmd_issues:
            recommendations.append(
                f"Found {len(cmd_issues)} potential command injection vulnerabilities. "
                "Avoid dynamic command execution."
            )

        # XSS
        xss_issues = [f for f in self.vulnerability_findings
                      if f.pattern_id in ['VULN004', 'VULN005']]
        if xss_issues:
            recommendations.append(
                f"Found {len(xss_issues)} potential XSS vulnerabilities. "
                "Sanitize all user input and use safe templating."
            )

        # Weak Crypto
        crypto_issues = [f for f in self.vulnerability_findings
                        if f.category == 'Cryptography']
        if crypto_issues:
            recommendations.append(
                f"Found {len(crypto_issues)} cryptographic issues. "
                "Use modern cryptographic algorithms (SHA-256+, bcrypt/argon2)."
            )

        # Authentication
        auth_issues = [f for f in self.vulnerability_findings
                       if f.category == 'Authentication']
        if auth_issues:
            recommendations.append(
                f"Found {len(auth_issues)} authentication issues. "
                "Implement proper password hashing and authentication mechanisms."
            )

        # Configuration
        config_issues = [f for f in self.vulnerability_findings
                        if f.category == 'Configuration']
        if config_issues:
            recommendations.append(
                f"Found {len(config_issues)} configuration issues. "
                "Review security settings for production deployment."
            )

        # OWASP Top 10
        owasp_categories = set(f.owasp for f in self.vulnerability_findings if f.owasp)
        if owasp_categories:
            recommendations.append(
                f"Issues found in OWASP Top 10 categories: {', '.join(owasp_categories)}. "
                "Review OWASP guidelines for mitigation strategies."
            )

        if not recommendations:
            recommendations.append(
                "No significant security issues detected. "
                "Continue following security best practices."
            )

        return recommendations


class OutputFormatter:
    """Format scan results for different output types"""

    @staticmethod
    def format_text(results: Dict, verbose: bool = False) -> str:
        """Format results as human-readable text"""
        output = []

        # Header
        output.append("=" * 80)
        output.append("SECURITY VULNERABILITY SCAN REPORT")
        output.append("=" * 80)
        output.append(f"Timestamp: {results['timestamp']}")
        output.append(f"Target: {results['target']}")
        output.append(f"Files Analyzed: {results['files_analyzed']}")
        output.append("")

        # Summary
        summary = results['summary']
        output.append("SUMMARY")
        output.append("-" * 80)
        output.append(f"Security Score: {summary['security_score']}/100")
        output.append(f"Total Findings: {summary['total_findings']}")
        output.append(f"  - Critical: {summary['critical']}")
        output.append(f"  - High: {summary['high']}")
        output.append(f"  - Medium: {summary['medium']}")
        output.append(f"  - Low: {summary['low']}")
        output.append(f"Hardcoded Secrets: {summary['total_secrets']}")
        output.append(f"Vulnerabilities: {summary['total_vulnerabilities']}")
        output.append("")

        # Hardcoded Secrets
        if results['secrets']:
            output.append("HARDCODED SECRETS")
            output.append("-" * 80)
            for secret in results['secrets']:
                output.append(f"[{secret['severity']}] {secret['type']}")
                output.append(f"  File: {secret['file']}:{secret['line']}")
                output.append(f"  Content: {secret['content'][:120]}")
                output.append(f"  Recommendation: {secret['recommendation']}")
                output.append("")

        # Vulnerabilities
        if results['vulnerabilities']:
            output.append("SECURITY VULNERABILITIES")
            output.append("-" * 80)
            for vuln in results['vulnerabilities']:
                output.append(f"[{vuln['severity']}] {vuln['message']}")
                output.append(f"  File: {vuln['file']}:{vuln['line']}")
                output.append(f"  Category: {vuln['category']}")
                if 'cwe' in vuln:
                    output.append(f"  CWE: {vuln['cwe']}")
                if 'owasp' in vuln:
                    output.append(f"  OWASP: {vuln['owasp']}")
                output.append(f"  Content: {vuln['content'][:120]}")
                output.append(f"  Recommendation: {vuln['recommendation']}")
                output.append("")

        # Recommendations
        output.append("RECOMMENDATIONS")
        output.append("-" * 80)
        for i, rec in enumerate(results['recommendations'], 1):
            output.append(f"{i}. {rec}")
        output.append("")

        output.append("=" * 80)

        return "\n".join(output)

    @staticmethod
    def format_json(results: Dict) -> str:
        """Format results as JSON"""
        return json.dumps(results, indent=2)

    @staticmethod
    def format_csv(results: Dict) -> str:
        """Format results as CSV"""
        output = StringIO()
        writer = csv.writer(output)

        # Header
        writer.writerow(['Type', 'Severity', 'Category', 'File', 'Line',
                        'Message', 'Recommendation', 'CWE', 'OWASP'])

        # Secrets
        for secret in results['secrets']:
            writer.writerow([
                'Secret',
                secret['severity'],
                'Hardcoded Secrets',
                secret['file'],
                secret['line'],
                secret['type'],
                secret['recommendation'],
                '',
                ''
            ])

        # Vulnerabilities
        for vuln in results['vulnerabilities']:
            writer.writerow([
                'Vulnerability',
                vuln['severity'],
                vuln['category'],
                vuln['file'],
                vuln['line'],
                vuln['message'],
                vuln['recommendation'],
                vuln.get('cwe', ''),
                vuln.get('owasp', '')
            ])

        return output.getvalue()


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Security Vulnerability Scanner - Detect security issues in legacy codebases',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Scan directory for all security issues
  %(prog)s --input /path/to/codebase

  # Scan with minimum severity filter
  %(prog)s --input /path/to/codebase --min-severity HIGH

  # Generate JSON report
  %(prog)s --input /path/to/codebase --output json --file report.json

  # Generate CSV report
  %(prog)s --input /path/to/codebase --output csv --file findings.csv

  # Verbose output with detailed progress
  %(prog)s --input /path/to/codebase --verbose

Severity Levels:
  CRITICAL - Immediate security risk (data breach, RCE)
  HIGH     - Significant security risk (auth bypass, injection)
  MEDIUM   - Moderate security risk (weak crypto, info disclosure)
  LOW      - Minor security risk (best practice violations)

Detection Categories:
  - Hardcoded Secrets (AWS keys, API keys, passwords, private keys)
  - OWASP Top 10 (SQL injection, XSS, command injection, etc.)
  - Authentication Issues (weak passwords, plain text)
  - Cryptography Issues (MD5/SHA1, weak random)
  - Configuration Issues (debug mode, CORS misconfiguration)
        """
    )

    parser.add_argument(
        '--input', '-i',
        required=True,
        help='File or directory to scan'
    )
    parser.add_argument(
        '--output', '-o',
        choices=['text', 'json', 'csv'],
        default='text',
        help='Output format (default: text)'
    )
    parser.add_argument(
        '--file', '-f',
        help='Save output to file (default: stdout)'
    )
    parser.add_argument(
        '--min-severity',
        choices=['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
        default='LOW',
        help='Minimum severity to report (default: LOW)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Verbose output with progress information'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 1.0.0'
    )

    args = parser.parse_args()

    # Validate input path
    if not os.path.exists(args.input):
        print(f"Error: Input path does not exist: {args.input}", file=sys.stderr)
        sys.exit(1)

    try:
        # Run scan
        scanner = SecurityVulnerabilityScanner(
            target_path=args.input,
            min_severity=args.min_severity,
            verbose=args.verbose
        )

        results = scanner.scan()

        # Format output
        formatter = OutputFormatter()
        if args.output == 'json':
            output_text = formatter.format_json(results)
        elif args.output == 'csv':
            output_text = formatter.format_csv(results)
        else:  # text
            output_text = formatter.format_text(results, verbose=args.verbose)

        # Write output
        if args.file:
            with open(args.file, 'w') as f:
                f.write(output_text)
            if args.verbose:
                print(f"\nReport saved to: {args.file}")
        else:
            print(output_text)

        # Exit code based on findings
        critical_count = results['summary']['critical']
        high_count = results['summary']['high']

        if critical_count > 0:
            sys.exit(2)  # Critical issues found
        elif high_count > 0:
            sys.exit(1)  # High severity issues found
        else:
            sys.exit(0)  # Success

    except KeyboardInterrupt:
        print("\nScan interrupted by user", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
