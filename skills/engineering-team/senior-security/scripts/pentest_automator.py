#!/usr/bin/env python3
"""
Pentest Automator
Automated security test generation tool for penetration testing

Features:
- SQL injection test case generation
- XSS payload generation
- Command injection test cases
- Path traversal probes
- SSRF test generation
- Authentication/authorization tests
- Test script generation (pytest, jest, curl)

Author: Claude Skills Engineering Team
"""

import os
import sys
import json
import csv
import argparse
import re
from io import StringIO
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Set, Any
from enum import Enum


class TestCategory(Enum):
    """Categories of security tests"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    SSRF = "ssrf"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    IDOR = "idor"
    FILE_UPLOAD = "file_upload"
    HEADER_INJECTION = "header_injection"


class TestFormat(Enum):
    """Output formats for generated tests"""
    PYTEST = "pytest"
    JEST = "jest"
    CURL = "curl"
    GENERIC = "generic"


@dataclass
class Endpoint:
    """Represents an API endpoint discovered in codebase"""
    method: str
    path: str
    file: str
    line: int
    params: List[str] = field(default_factory=list)
    body_params: List[str] = field(default_factory=list)
    auth_required: bool = False


@dataclass
class TestCase:
    """Represents a generated security test case"""
    id: str
    category: str
    name: str
    description: str
    target: str
    method: str
    payload: str
    expected_behavior: str
    severity: str
    test_code: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class TestSuite:
    """Collection of test cases for an endpoint"""
    endpoint: str
    method: str
    test_cases: List[TestCase] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'endpoint': self.endpoint,
            'method': self.method,
            'test_cases': [tc.to_dict() for tc in self.test_cases]
        }


class PayloadGenerator:
    """Generates security testing payloads"""

    # SQL Injection payloads
    SQL_INJECTION_PAYLOADS = [
        ("basic_quote", "' OR '1'='1", "Basic SQL injection with quotes"),
        ("comment_bypass", "' OR 1=1--", "SQL injection with comment"),
        ("union_select", "' UNION SELECT NULL,NULL--", "UNION-based injection"),
        ("time_based", "' OR SLEEP(5)--", "Time-based blind injection"),
        ("error_based", "' AND 1=CONVERT(int,(SELECT TOP 1 table_name FROM information_schema.tables))--", "Error-based injection"),
        ("stacked_query", "'; DROP TABLE users--", "Stacked query injection"),
        ("boolean_blind", "' AND 1=1--", "Boolean-based blind injection"),
        ("like_injection", "' OR username LIKE '%admin%'--", "LIKE-based injection"),
        ("order_by", "' ORDER BY 1--", "ORDER BY injection for column enumeration"),
        ("hex_encoded", "0x27204f5220273127", "Hex-encoded injection"),
    ]

    # XSS payloads
    XSS_PAYLOADS = [
        ("basic_script", "<script>alert('XSS')</script>", "Basic script tag XSS"),
        ("img_onerror", "<img src=x onerror=alert('XSS')>", "Image onerror event"),
        ("svg_onload", "<svg onload=alert('XSS')>", "SVG onload event"),
        ("body_onload", "<body onload=alert('XSS')>", "Body onload event"),
        ("event_handler", "<div onmouseover=alert('XSS')>hover</div>", "Event handler injection"),
        ("javascript_uri", "javascript:alert('XSS')", "JavaScript URI scheme"),
        ("encoded_script", "%3Cscript%3Ealert('XSS')%3C/script%3E", "URL-encoded XSS"),
        ("dom_based", "';alert('XSS');//", "DOM-based XSS"),
        ("template_injection", "{{constructor.constructor('alert(1)')()}}", "Template injection"),
        ("attribute_escape", "\" onfocus=alert('XSS') autofocus=\"", "Attribute escape XSS"),
    ]

    # Command Injection payloads
    COMMAND_INJECTION_PAYLOADS = [
        ("semicolon", "; ls -la", "Semicolon command separator"),
        ("pipe", "| cat /etc/passwd", "Pipe to command"),
        ("ampersand", "& whoami", "Background command"),
        ("backtick", "`id`", "Backtick command substitution"),
        ("dollar_paren", "$(whoami)", "Dollar-paren substitution"),
        ("newline", "\nid", "Newline command separator"),
        ("and_operator", "&& cat /etc/passwd", "AND operator chaining"),
        ("or_operator", "|| id", "OR operator chaining"),
        ("encoded_newline", "%0aid", "URL-encoded newline"),
        ("null_byte", "file.txt%00.jpg", "Null byte injection"),
    ]

    # Path Traversal payloads
    PATH_TRAVERSAL_PAYLOADS = [
        ("basic_dotdot", "../../../etc/passwd", "Basic directory traversal"),
        ("encoded_dotdot", "..%2f..%2f..%2fetc%2fpasswd", "URL-encoded traversal"),
        ("double_encoded", "..%252f..%252f..%252fetc%252fpasswd", "Double URL-encoded"),
        ("unicode", "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd", "Unicode encoding"),
        ("backslash", "..\\..\\..\\etc\\passwd", "Backslash traversal"),
        ("null_byte", "../../../etc/passwd%00.jpg", "Null byte bypass"),
        ("windows_path", "..\\..\\..\\windows\\system32\\config\\sam", "Windows path traversal"),
        ("absolute_path", "/etc/passwd", "Absolute path injection"),
        ("wrapper", "php://filter/convert.base64-encode/resource=index.php", "PHP wrapper"),
        ("file_uri", "file:///etc/passwd", "File URI scheme"),
    ]

    # SSRF payloads
    SSRF_PAYLOADS = [
        ("localhost", "http://localhost:22", "Localhost port scan"),
        ("internal_ip", "http://192.168.1.1", "Internal network access"),
        ("aws_metadata", "http://169.254.169.254/latest/meta-data/", "AWS metadata endpoint"),
        ("gcp_metadata", "http://metadata.google.internal/computeMetadata/v1/", "GCP metadata endpoint"),
        ("azure_metadata", "http://169.254.169.254/metadata/instance", "Azure metadata endpoint"),
        ("dns_rebind", "http://localtest.me:8080", "DNS rebinding test"),
        ("ipv6_localhost", "http://[::1]:80", "IPv6 localhost"),
        ("decimal_ip", "http://2130706433/", "Decimal IP (127.0.0.1)"),
        ("octal_ip", "http://0177.0.0.1/", "Octal IP format"),
        ("file_protocol", "file:///etc/passwd", "File protocol SSRF"),
    ]

    # Authentication bypass payloads
    AUTH_BYPASS_PAYLOADS = [
        ("empty_password", "", "Empty password"),
        ("null_password", "null", "Null string password"),
        ("admin_default", "admin", "Default admin password"),
        ("sql_bypass", "' OR '1'='1", "SQL injection in auth"),
        ("jwt_none", "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.", "JWT none algorithm"),
        ("jwt_weak_secret", "secret", "Common JWT secret"),
        ("bearer_null", "Bearer null", "Null bearer token"),
        ("basic_encoded", "YWRtaW46YWRtaW4=", "Base64 admin:admin"),
        ("header_bypass", "X-Forwarded-For: 127.0.0.1", "Header-based bypass"),
        ("cookie_manipulation", "admin=true; role=admin", "Cookie manipulation"),
    ]

    # IDOR payloads (ID manipulation)
    IDOR_PAYLOADS = [
        ("increment_id", "+1", "Increment numeric ID"),
        ("decrement_id", "-1", "Decrement numeric ID"),
        ("zero_id", "0", "Zero ID"),
        ("negative_id", "-1", "Negative ID"),
        ("large_id", "999999999", "Large numeric ID"),
        ("uuid_manipulation", "00000000-0000-0000-0000-000000000000", "Nil UUID"),
        ("array_access", "id[]=1&id[]=2", "Array parameter"),
        ("param_pollution", "?id=1&id=2", "Parameter pollution"),
        ("json_array", "[1,2,3]", "JSON array injection"),
        ("wildcard", "*", "Wildcard character"),
    ]

    @classmethod
    def get_payloads(cls, category: TestCategory) -> List[tuple]:
        """Get payloads for a specific category"""
        payload_map = {
            TestCategory.SQL_INJECTION: cls.SQL_INJECTION_PAYLOADS,
            TestCategory.XSS: cls.XSS_PAYLOADS,
            TestCategory.COMMAND_INJECTION: cls.COMMAND_INJECTION_PAYLOADS,
            TestCategory.PATH_TRAVERSAL: cls.PATH_TRAVERSAL_PAYLOADS,
            TestCategory.SSRF: cls.SSRF_PAYLOADS,
            TestCategory.AUTHENTICATION: cls.AUTH_BYPASS_PAYLOADS,
            TestCategory.IDOR: cls.IDOR_PAYLOADS,
        }
        return payload_map.get(category, [])


class EndpointDiscovery:
    """Discovers API endpoints from codebase"""

    # Patterns for different frameworks
    ENDPOINT_PATTERNS = {
        'express': [
            (r'(?:app|router)\.(get|post|put|delete|patch)\s*\(\s*[\'"]([^\'"]+)[\'"]', 'express_route'),
            (r'@(?:Get|Post|Put|Delete|Patch)\s*\(\s*[\'"]([^\'"]+)[\'"]', 'nestjs_decorator'),
        ],
        'flask': [
            (r'@(?:app|blueprint)\.route\s*\(\s*[\'"]([^\'"]+)[\'"](?:.*?methods\s*=\s*\[([^\]]+)\])?', 'flask_route'),
            (r'@(?:app|blueprint)\.(get|post|put|delete)\s*\(\s*[\'"]([^\'"]+)[\'"]', 'flask_method'),
        ],
        'django': [
            (r'path\s*\(\s*[\'"]([^\'"]+)[\'"]', 'django_path'),
            (r'url\s*\(\s*r?[\'"]([^\'"]+)[\'"]', 'django_url'),
        ],
        'fastapi': [
            (r'@(?:app|router)\.(get|post|put|delete|patch)\s*\(\s*[\'"]([^\'"]+)[\'"]', 'fastapi_route'),
        ],
        'spring': [
            (r'@(?:Get|Post|Put|Delete|Patch)Mapping\s*\(\s*(?:value\s*=\s*)?[\'"]([^\'"]+)[\'"]', 'spring_mapping'),
            (r'@RequestMapping\s*\(\s*(?:value\s*=\s*)?[\'"]([^\'"]+)[\'"]', 'spring_request'),
        ],
        'rails': [
            (r'(?:get|post|put|delete|patch)\s+[\'"]([^\'"]+)[\'"]', 'rails_route'),
            (r'resources?\s+:(\w+)', 'rails_resource'),
        ],
    }

    # Parameter extraction patterns
    PARAM_PATTERNS = [
        r':(\w+)',                    # Express/Rails style :param
        r'\{(\w+)\}',                 # Flask/FastAPI style {param}
        r'<(?:\w+:)?(\w+)>',         # Flask angle bracket style
        r'\$(\w+)',                   # Dollar style
        r'\[(\w+)\]',                 # Bracket style
    ]

    def __init__(self, target_path: Path, verbose: bool = False):
        self.target_path = target_path
        self.verbose = verbose
        self.endpoints: List[Endpoint] = []

    def discover(self) -> List[Endpoint]:
        """Discover endpoints from codebase"""
        extensions = {'.py', '.js', '.ts', '.java', '.rb', '.go', '.php'}

        if self.target_path.is_file():
            files = [self.target_path]
        else:
            files = []
            for ext in extensions:
                files.extend(self.target_path.rglob(f'*{ext}'))

        for file_path in files:
            try:
                self._analyze_file(file_path)
            except Exception as e:
                if self.verbose:
                    print(f"  Warning: Could not analyze {file_path}: {e}")

        return self.endpoints

    def _analyze_file(self, file_path: Path):
        """Analyze a single file for endpoints"""
        try:
            content = file_path.read_text(errors='ignore')
        except Exception:
            return

        lines = content.split('\n')

        for framework, patterns in self.ENDPOINT_PATTERNS.items():
            for pattern, pattern_type in patterns:
                for i, line in enumerate(lines, 1):
                    matches = re.findall(pattern, line, re.IGNORECASE)
                    for match in matches:
                        endpoint = self._create_endpoint(match, pattern_type, file_path, i)
                        if endpoint:
                            self.endpoints.append(endpoint)

    def _create_endpoint(self, match: tuple, pattern_type: str, file_path: Path, line: int) -> Optional[Endpoint]:
        """Create an endpoint from a regex match"""
        if isinstance(match, str):
            method = 'GET'
            path = match
        elif len(match) == 2:
            method, path = match
            method = method.upper()
        else:
            return None

        # Extract path parameters
        params = []
        for param_pattern in self.PARAM_PATTERNS:
            params.extend(re.findall(param_pattern, path))

        # Normalize path
        if not path.startswith('/'):
            path = '/' + path

        return Endpoint(
            method=method,
            path=path,
            file=str(file_path),
            line=line,
            params=params
        )


class TestGenerator:
    """Generates security test cases"""

    def __init__(self, base_url: str = "http://localhost:8080", verbose: bool = False):
        self.base_url = base_url.rstrip('/')
        self.verbose = verbose
        self.test_counter = 0

    def generate_tests(self, endpoint: Endpoint, categories: List[TestCategory]) -> TestSuite:
        """Generate tests for an endpoint"""
        suite = TestSuite(endpoint=endpoint.path, method=endpoint.method)

        for category in categories:
            tests = self._generate_category_tests(endpoint, category)
            suite.test_cases.extend(tests)

        return suite

    def _generate_category_tests(self, endpoint: Endpoint, category: TestCategory) -> List[TestCase]:
        """Generate tests for a specific category"""
        tests = []
        payloads = PayloadGenerator.get_payloads(category)

        for payload_id, payload, description in payloads:
            self.test_counter += 1
            test = TestCase(
                id=f"TC-{self.test_counter:04d}",
                category=category.value,
                name=f"{category.value}_{payload_id}",
                description=description,
                target=f"{self.base_url}{endpoint.path}",
                method=endpoint.method,
                payload=payload,
                expected_behavior=self._get_expected_behavior(category),
                severity=self._get_severity(category)
            )
            tests.append(test)

        return tests

    def _get_expected_behavior(self, category: TestCategory) -> str:
        """Get expected behavior for a category"""
        behaviors = {
            TestCategory.SQL_INJECTION: "Application should reject or sanitize the input. No SQL errors or data leakage.",
            TestCategory.XSS: "Application should escape or reject the input. No script execution.",
            TestCategory.COMMAND_INJECTION: "Application should reject the input. No command execution.",
            TestCategory.PATH_TRAVERSAL: "Application should reject or sanitize the path. No file access outside allowed directories.",
            TestCategory.SSRF: "Application should validate and restrict URLs. No access to internal resources.",
            TestCategory.AUTHENTICATION: "Application should properly validate credentials. No authentication bypass.",
            TestCategory.AUTHORIZATION: "Application should enforce access controls. No unauthorized access.",
            TestCategory.IDOR: "Application should validate resource ownership. No access to other users' resources.",
        }
        return behaviors.get(category, "Application should handle input securely.")

    def _get_severity(self, category: TestCategory) -> str:
        """Get severity level for a category"""
        severities = {
            TestCategory.SQL_INJECTION: "CRITICAL",
            TestCategory.COMMAND_INJECTION: "CRITICAL",
            TestCategory.SSRF: "HIGH",
            TestCategory.AUTHENTICATION: "CRITICAL",
            TestCategory.AUTHORIZATION: "HIGH",
            TestCategory.PATH_TRAVERSAL: "HIGH",
            TestCategory.XSS: "MEDIUM",
            TestCategory.IDOR: "HIGH",
        }
        return severities.get(category, "MEDIUM")


class TestScriptGenerator:
    """Generates executable test scripts"""

    def __init__(self, format_type: TestFormat):
        self.format = format_type

    def generate(self, suites: List[TestSuite]) -> str:
        """Generate test script for all suites"""
        if self.format == TestFormat.PYTEST:
            return self._generate_pytest(suites)
        elif self.format == TestFormat.JEST:
            return self._generate_jest(suites)
        elif self.format == TestFormat.CURL:
            return self._generate_curl(suites)
        else:
            return self._generate_generic(suites)

    def _generate_pytest(self, suites: List[TestSuite]) -> str:
        """Generate pytest test file"""
        lines = [
            '"""',
            'Auto-generated Security Test Suite',
            f'Generated: {datetime.now().isoformat()}',
            '"""',
            '',
            'import pytest',
            'import requests',
            '',
            '',
            'BASE_URL = "http://localhost:8080"',
            '',
            '',
        ]

        for suite in suites:
            class_name = self._sanitize_name(suite.endpoint)
            lines.append(f'class Test{class_name}:')
            lines.append(f'    """Security tests for {suite.method} {suite.endpoint}"""')
            lines.append('')

            for tc in suite.test_cases:
                method_name = f"test_{tc.name}"
                lines.append(f'    def {method_name}(self):')
                lines.append(f'        """')
                lines.append(f'        {tc.description}')
                lines.append(f'        Severity: {tc.severity}')
                lines.append(f'        """')
                lines.append(f'        url = f"{{BASE_URL}}{suite.endpoint}"')
                lines.append(f'        payload = {repr(tc.payload)}')
                lines.append('')

                if suite.method == 'GET':
                    lines.append(f'        response = requests.get(url, params={{"input": payload}})')
                else:
                    lines.append(f'        response = requests.{suite.method.lower()}(url, json={{"input": payload}})')

                lines.append('')
                lines.append('        # Verify secure handling')
                lines.append('        assert response.status_code != 500, "Server error indicates potential vulnerability"')
                lines.append(f'        assert payload not in response.text, "Payload reflected in response"')
                lines.append('')

            lines.append('')

        return '\n'.join(lines)

    def _generate_jest(self, suites: List[TestSuite]) -> str:
        """Generate Jest test file"""
        lines = [
            '/**',
            ' * Auto-generated Security Test Suite',
            f' * Generated: {datetime.now().isoformat()}',
            ' */',
            '',
            "const axios = require('axios');",
            '',
            "const BASE_URL = 'http://localhost:8080';",
            '',
        ]

        for suite in suites:
            desc_name = f'{suite.method} {suite.endpoint}'
            lines.append(f"describe('{desc_name}', () => {{")

            for tc in suite.test_cases:
                lines.append(f"  test('{tc.name} - {tc.description}', async () => {{")
                lines.append(f"    // Severity: {tc.severity}")
                lines.append(f"    const payload = {json.dumps(tc.payload)};")
                lines.append(f"    const url = `${{BASE_URL}}{suite.endpoint}`;")
                lines.append('')

                if suite.method == 'GET':
                    lines.append('    const response = await axios.get(url, { params: { input: payload } });')
                else:
                    lines.append(f'    const response = await axios.{suite.method.lower()}(url, {{ input: payload }});')

                lines.append('')
                lines.append("    // Verify secure handling")
                lines.append("    expect(response.status).not.toBe(500);")
                lines.append("    expect(response.data).not.toContain(payload);")
                lines.append('  });')
                lines.append('')

            lines.append('});')
            lines.append('')

        return '\n'.join(lines)

    def _generate_curl(self, suites: List[TestSuite]) -> str:
        """Generate curl commands"""
        lines = [
            '#!/bin/bash',
            '# Auto-generated Security Test Suite',
            f'# Generated: {datetime.now().isoformat()}',
            '',
            'BASE_URL="http://localhost:8080"',
            '',
            'echo "=== Security Test Suite ==="',
            '',
        ]

        for suite in suites:
            lines.append(f'echo ""')
            lines.append(f'echo "=== Testing {suite.method} {suite.endpoint} ==="')
            lines.append('')

            for tc in suite.test_cases:
                lines.append(f'# {tc.id}: {tc.description}')
                lines.append(f'# Severity: {tc.severity}')

                escaped_payload = tc.payload.replace("'", "'\\''")

                if suite.method == 'GET':
                    encoded_payload = tc.payload.replace(' ', '%20').replace('"', '%22')
                    lines.append(f'echo "Testing: {tc.name}"')
                    lines.append(f'curl -s -o /dev/null -w "%{{http_code}}" "$BASE_URL{suite.endpoint}?input={encoded_payload}"')
                else:
                    lines.append(f'echo "Testing: {tc.name}"')
                    lines.append(f"curl -s -o /dev/null -w \"%{{http_code}}\" -X {suite.method} \"$BASE_URL{suite.endpoint}\" -H 'Content-Type: application/json' -d '{{\"input\":\"{escaped_payload}\"}}'")

                lines.append('echo ""')
                lines.append('')

        lines.append('echo ""')
        lines.append('echo "=== Test Suite Complete ==="')

        return '\n'.join(lines)

    def _generate_generic(self, suites: List[TestSuite]) -> str:
        """Generate generic test documentation"""
        lines = [
            '# Security Test Suite',
            f'Generated: {datetime.now().isoformat()}',
            '',
            '## Overview',
            '',
        ]

        total_tests = sum(len(s.test_cases) for s in suites)
        lines.append(f'Total endpoints: {len(suites)}')
        lines.append(f'Total test cases: {total_tests}')
        lines.append('')

        for suite in suites:
            lines.append(f'## {suite.method} {suite.endpoint}')
            lines.append('')
            lines.append('| ID | Category | Name | Severity | Payload |')
            lines.append('|----|----------|------|----------|---------|')

            for tc in suite.test_cases:
                payload_display = tc.payload[:30] + '...' if len(tc.payload) > 30 else tc.payload
                payload_display = payload_display.replace('|', '\\|')
                lines.append(f'| {tc.id} | {tc.category} | {tc.name} | {tc.severity} | `{payload_display}` |')

            lines.append('')

        return '\n'.join(lines)

    def _sanitize_name(self, name: str) -> str:
        """Sanitize name for use as class/function name"""
        # Remove leading slashes and replace special chars
        name = name.lstrip('/')
        name = re.sub(r'[^a-zA-Z0-9]', '_', name)
        name = re.sub(r'_+', '_', name)
        name = name.strip('_')
        return name.title().replace('_', '') or 'Root'


class PentestAutomator:
    """Main penetration test automation tool"""

    def __init__(self, target_path: str, base_url: str = "http://localhost:8080",
                 categories: Optional[List[str]] = None,
                 test_format: str = "generic",
                 verbose: bool = False):
        self.target_path = Path(target_path)
        self.base_url = base_url
        self.verbose = verbose
        self.test_format = TestFormat(test_format) if test_format in [f.value for f in TestFormat] else TestFormat.GENERIC

        # Parse categories
        if categories:
            self.categories = []
            for cat in categories:
                try:
                    self.categories.append(TestCategory(cat.lower()))
                except ValueError:
                    if verbose:
                        print(f"  Warning: Unknown category '{cat}'")
        else:
            # Default to common vulnerability categories
            self.categories = [
                TestCategory.SQL_INJECTION,
                TestCategory.XSS,
                TestCategory.COMMAND_INJECTION,
                TestCategory.PATH_TRAVERSAL,
                TestCategory.SSRF,
                TestCategory.AUTHENTICATION,
                TestCategory.IDOR,
            ]

        self.results = {
            'tool': 'PentestAutomator',
            'version': '1.0.0',
            'timestamp': datetime.now().isoformat(),
            'target': str(self.target_path),
            'base_url': self.base_url,
            'categories': [c.value for c in self.categories],
            'test_format': self.test_format.value,
            'endpoints': [],
            'test_suites': [],
            'summary': {}
        }

    def run(self) -> Dict:
        """Execute the penetration test automation"""
        print(f"ðŸ” Running Pentest Automator...")
        print(f"ðŸ“ Target: {self.target_path}")
        print(f"ðŸŒ Base URL: {self.base_url}")
        print(f"ðŸ“‹ Categories: {', '.join(c.value for c in self.categories)}")

        try:
            self.validate_target()
            self.discover_endpoints()
            self.generate_tests()
            self.generate_report()

            print("âœ… Pentest automation completed!")
            return self.results

        except Exception as e:
            print(f"âŒ Error: {e}")
            if self.verbose:
                import traceback
                traceback.print_exc()
            sys.exit(1)

    def validate_target(self):
        """Validate target path exists"""
        if not self.target_path.exists():
            raise ValueError(f"Target path does not exist: {self.target_path}")

        if self.verbose:
            print(f"âœ“ Target validated: {self.target_path}")

    def discover_endpoints(self):
        """Discover API endpoints in codebase"""
        if self.verbose:
            print("ðŸ” Discovering endpoints...")

        discovery = EndpointDiscovery(self.target_path, self.verbose)
        endpoints = discovery.discover()

        self.results['endpoints'] = [
            {
                'method': e.method,
                'path': e.path,
                'file': e.file,
                'line': e.line,
                'params': e.params
            }
            for e in endpoints
        ]

        self.endpoints = endpoints

        if self.verbose:
            print(f"âœ“ Discovered {len(endpoints)} endpoints")

    def generate_tests(self):
        """Generate security tests for discovered endpoints"""
        if self.verbose:
            print("ðŸ§ª Generating test cases...")

        generator = TestGenerator(self.base_url, self.verbose)
        suites = []

        for endpoint in self.endpoints:
            suite = generator.generate_tests(endpoint, self.categories)
            suites.append(suite)

        self.results['test_suites'] = [s.to_dict() for s in suites]
        self.suites = suites

        # Generate test script
        script_gen = TestScriptGenerator(self.test_format)
        self.results['test_script'] = script_gen.generate(suites)

        total_tests = sum(len(s.test_cases) for s in suites)
        if self.verbose:
            print(f"âœ“ Generated {total_tests} test cases")

    def generate_report(self):
        """Generate summary report"""
        total_tests = sum(len(s.test_cases) for s in self.suites)

        # Count by severity
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        category_counts = {}

        for suite in self.suites:
            for tc in suite.test_cases:
                severity_counts[tc.severity] = severity_counts.get(tc.severity, 0) + 1
                category_counts[tc.category] = category_counts.get(tc.category, 0) + 1

        self.results['summary'] = {
            'total_endpoints': len(self.endpoints),
            'total_test_cases': total_tests,
            'by_severity': severity_counts,
            'by_category': category_counts,
            'test_format': self.test_format.value
        }

    def format_text_output(self) -> str:
        """Format results as human-readable text"""
        lines = [
            "=" * 60,
            "PENTEST AUTOMATOR REPORT",
            "=" * 60,
            "",
            f"Target: {self.results['target']}",
            f"Base URL: {self.results['base_url']}",
            f"Timestamp: {self.results['timestamp']}",
            f"Test Format: {self.results['test_format']}",
            "",
            "-" * 60,
            "SUMMARY",
            "-" * 60,
            f"Endpoints Discovered: {self.results['summary']['total_endpoints']}",
            f"Test Cases Generated: {self.results['summary']['total_test_cases']}",
            "",
            "By Severity:",
        ]

        for severity, count in self.results['summary']['by_severity'].items():
            lines.append(f"  {severity}: {count}")

        lines.append("")
        lines.append("By Category:")
        for category, count in self.results['summary']['by_category'].items():
            lines.append(f"  {category}: {count}")

        lines.extend([
            "",
            "-" * 60,
            "DISCOVERED ENDPOINTS",
            "-" * 60,
        ])

        for ep in self.results['endpoints']:
            lines.append(f"  {ep['method']} {ep['path']}")
            lines.append(f"    File: {ep['file']}:{ep['line']}")
            if ep['params']:
                lines.append(f"    Params: {', '.join(ep['params'])}")

        lines.extend([
            "",
            "-" * 60,
            "TEST SUITES",
            "-" * 60,
        ])

        for suite in self.results['test_suites'][:5]:  # Limit output
            lines.append(f"\n{suite['method']} {suite['endpoint']}:")
            for tc in suite['test_cases'][:3]:  # Show first 3 tests
                lines.append(f"  [{tc['severity']}] {tc['id']}: {tc['name']}")
                lines.append(f"    {tc['description']}")
            if len(suite['test_cases']) > 3:
                lines.append(f"  ... and {len(suite['test_cases']) - 3} more tests")

        if len(self.results['test_suites']) > 5:
            lines.append(f"\n... and {len(self.results['test_suites']) - 5} more endpoints")

        lines.extend([
            "",
            "-" * 60,
            "GENERATED TEST SCRIPT",
            "-" * 60,
            "",
        ])

        # Show first 50 lines of test script
        script_lines = self.results['test_script'].split('\n')[:50]
        lines.extend(script_lines)
        if len(self.results['test_script'].split('\n')) > 50:
            lines.append(f"\n... ({len(self.results['test_script'].split(chr(10))) - 50} more lines)")

        lines.extend([
            "",
            "=" * 60,
        ])

        return '\n'.join(lines)

    def format_csv_output(self) -> str:
        """Format results as CSV"""
        output = StringIO()
        writer = csv.writer(output)

        # Header
        writer.writerow([
            'test_id', 'category', 'name', 'severity',
            'endpoint', 'method', 'payload', 'description'
        ])

        # Data rows
        for suite in self.results['test_suites']:
            for tc in suite['test_cases']:
                writer.writerow([
                    tc['id'],
                    tc['category'],
                    tc['name'],
                    tc['severity'],
                    suite['endpoint'],
                    suite['method'],
                    tc['payload'],
                    tc['description']
                ])

        return output.getvalue()


def main():
    """Main entry point with CLI interface"""
    parser = argparse.ArgumentParser(
        description="Pentest Automator - Automated security test generation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -i ./src
  %(prog)s -i ./api --url http://localhost:3000
  %(prog)s -i ./app --categories sql_injection,xss --format pytest
  %(prog)s -i ./src -o json -f tests.json

Categories:
  sql_injection     SQL injection payloads
  xss               Cross-site scripting payloads
  command_injection Command injection payloads
  path_traversal    Path traversal payloads
  ssrf              Server-side request forgery
  authentication    Authentication bypass tests
  idor              Insecure direct object references

Test Formats:
  pytest            Python pytest test file
  jest              JavaScript Jest test file
  curl              Bash curl commands
  generic           Markdown documentation

For more information, see the skill documentation.
        """
    )

    parser.add_argument(
        '--input', '-i',
        required=True,
        dest='target',
        help='Input directory or file to analyze for endpoints'
    )

    parser.add_argument(
        '--url', '-u',
        default='http://localhost:8080',
        help='Base URL for generated tests (default: http://localhost:8080)'
    )

    parser.add_argument(
        '--categories',
        help='Comma-separated list of test categories (default: all)'
    )

    parser.add_argument(
        '--format',
        choices=['pytest', 'jest', 'curl', 'generic'],
        default='generic',
        dest='test_format',
        help='Output format for generated tests (default: generic)'
    )

    parser.add_argument(
        '--output', '-o',
        choices=['text', 'json', 'csv'],
        default='text',
        help='Report output format (default: text)'
    )

    parser.add_argument(
        '--config', '-c',
        help='Configuration file path'
    )

    parser.add_argument(
        '--file', '-f',
        help='Write output to file instead of stdout'
    )

    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output'
    )

    args = parser.parse_args()

    # Parse categories
    categories = None
    if args.categories:
        categories = [c.strip() for c in args.categories.split(',')]

    # Create and run tool
    tool = PentestAutomator(
        target_path=args.target,
        base_url=args.url,
        categories=categories,
        test_format=args.test_format,
        verbose=args.verbose
    )

    results = tool.run()

    # Format output
    if args.output == 'json':
        output = json.dumps(results, indent=2)
    elif args.output == 'csv':
        output = tool.format_csv_output()
    else:
        output = tool.format_text_output()

    # Write or print output
    if args.file:
        with open(args.file, 'w') as f:
            f.write(output)
        print(f"Results written to {args.file}")
    else:
        print(output)


if __name__ == '__main__':
    main()
